"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const tslib_1 = require("tslib");
const di_1 = require("@discordx/di");
const discord_js_1 = require("discord.js");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const index_js_1 = require("./index.js");
/**
 * Extend original client class of discord.js
 *
 * @param options - Client options
 * ___
 *
 * [View Documentation](https://discordx.js.org/docs/discordx/basics/client)
 */
class Client extends discord_js_1.Client {
    _botId;
    _isBuilt = false;
    _prefix;
    _simpleCommandConfig;
    _silent;
    _botGuilds = [];
    _guards = [];
    logger;
    // static getters
    static get applicationCommandSlashesFlat() {
        return index_js_1.MetadataStorage.instance.applicationCommandSlashesFlat;
    }
    static get applicationCommandSlashes() {
        return index_js_1.MetadataStorage.instance.applicationCommandSlashes;
    }
    static get applicationCommandUsers() {
        return index_js_1.MetadataStorage.instance.applicationCommandUsers;
    }
    static get applicationCommandMessages() {
        return index_js_1.MetadataStorage.instance.applicationCommandMessages;
    }
    static get applicationCommandSlashOptions() {
        return index_js_1.MetadataStorage.instance.applicationCommandSlashOptions;
    }
    static get applicationCommands() {
        return index_js_1.MetadataStorage.instance.applicationCommands;
    }
    static get applicationCommandSlashGroups() {
        return index_js_1.MetadataStorage.instance.applicationCommandSlashGroups;
    }
    static get applicationCommandSlashSubGroups() {
        return index_js_1.MetadataStorage.instance.applicationCommandSlashSubGroups;
    }
    static get buttonComponents() {
        return index_js_1.MetadataStorage.instance.buttonComponents;
    }
    static get discords() {
        return index_js_1.MetadataStorage.instance.discords;
    }
    static get events() {
        return index_js_1.MetadataStorage.instance.events;
    }
    static get instance() {
        return index_js_1.MetadataStorage.instance;
    }
    static get modalComponents() {
        return index_js_1.MetadataStorage.instance.modalComponents;
    }
    static get reactions() {
        return index_js_1.MetadataStorage.instance.reactions;
    }
    static get selectMenuComponents() {
        return index_js_1.MetadataStorage.instance.selectMenuComponents;
    }
    static get simpleCommandsByName() {
        return index_js_1.MetadataStorage.instance.simpleCommandsByName;
    }
    static get simpleCommandsByPrefix() {
        return index_js_1.MetadataStorage.instance.simpleCommandsByPrefix;
    }
    static get simpleCommands() {
        return index_js_1.MetadataStorage.instance.simpleCommands;
    }
    // map static getters
    get applicationCommandSlashes() {
        return Client.applicationCommandSlashes;
    }
    get applicationCommandSlashesFlat() {
        return Client.applicationCommandSlashesFlat;
    }
    get applicationCommandSlashOptions() {
        return Client.applicationCommandSlashOptions;
    }
    get applicationCommandSlashGroups() {
        return Client.applicationCommandSlashGroups;
    }
    get applicationCommandSlashSubGroups() {
        return Client.applicationCommandSlashSubGroups;
    }
    get applicationCommandUsers() {
        return Client.applicationCommandUsers;
    }
    get applicationCommandMessages() {
        return Client.applicationCommandMessages;
    }
    get applicationCommands() {
        return Client.applicationCommands;
    }
    get buttonComponents() {
        return Client.buttonComponents;
    }
    get discords() {
        return Client.discords;
    }
    get events() {
        return Client.events;
    }
    get instance() {
        return Client.instance;
    }
    get modalComponents() {
        return Client.modalComponents;
    }
    get reactions() {
        return Client.reactions;
    }
    get selectMenuComponents() {
        return Client.selectMenuComponents;
    }
    get simpleCommandsByName() {
        return Client.simpleCommandsByName;
    }
    get simpleCommandsByPrefix() {
        return Client.simpleCommandsByPrefix;
    }
    get simpleCommands() {
        return Client.simpleCommands;
    }
    // client getters
    get botResolvedGuilds() {
        return (0, index_js_1.resolveIGuilds)(this, undefined, this._botGuilds);
    }
    get botGuilds() {
        return this._botGuilds;
    }
    set botGuilds(value) {
        this._botGuilds = value;
    }
    get botId() {
        return this._botId;
    }
    set botId(value) {
        this._botId = value;
    }
    get guards() {
        return this._guards;
    }
    set guards(value) {
        this._guards = value;
    }
    get prefix() {
        return this._prefix;
    }
    set prefix(value) {
        this._prefix = value;
    }
    get simpleCommandConfig() {
        return this._simpleCommandConfig;
    }
    set simpleCommandConfig(value) {
        this._simpleCommandConfig = value;
    }
    get silent() {
        return this._silent;
    }
    set silent(value) {
        this._silent = value;
    }
    /**
     * Extend original client class of discord.js
     *
     * @param options - Client options
     * ___
     *
     * [View Documentation](https://discordx.js.org/docs/discordx/basics/client)
     */
    constructor(options) {
        super(options);
        this._silent = options?.silent ?? true;
        this.guards = options.guards ?? [];
        this.botGuilds = options.botGuilds ?? [];
        this._botId = options.botId ?? "bot";
        this._prefix = options.simpleCommand?.prefix ?? ["!"];
        this._simpleCommandConfig = options.simpleCommand;
        this.logger = options.logger ?? console;
    }
    /**
     * Start bot
     *
     * @param token - Bot token
     * @param log - Enable log
     */
    async login(token, log) {
        await this.build(log);
        if (log ?? !this.silent) {
            this.logger.log(`${this.user?.username ?? this.botId} >> connecting discord...\n`);
        }
        return super.login(token);
    }
    /**
     * Print information about all events and commands to your console
     */
    printDebug() {
        if (!this.instance.isBuilt) {
            this.logger.error("Build the app before running this method with client.build()");
            return;
        }
        this.logger.log("client >> Events");
        if (this.events.length) {
            this.events.forEach((event) => {
                const eventName = event.event;
                this.logger.log(`>> ${eventName} (${event.classRef.name}.${event.key})`);
            });
        }
        else {
            this.logger.log("\tNo event detected");
        }
        this.logger.log("");
        this.logger.log("client >> buttons");
        if (this.buttonComponents.length) {
            this.buttonComponents.forEach((btn) => {
                this.logger.log(`>> ${btn.id.toString()} (${btn.classRef.name}.${btn.key})`);
            });
        }
        else {
            this.logger.log("\tNo buttons detected");
        }
        this.logger.log("");
        this.logger.log("client >> select menu's");
        if (this.selectMenuComponents.length) {
            this.selectMenuComponents.forEach((menu) => {
                this.logger.log(`>> ${menu.id.toString()} (${menu.classRef.name}.${menu.key})`);
            });
        }
        else {
            this.logger.log("\tNo select menu detected");
        }
        this.logger.log("");
        this.logger.log("client >> modals");
        if (this.modalComponents.length) {
            this.modalComponents.forEach((menu) => {
                this.logger.log(`>> ${menu.id.toString()} (${menu.classRef.name}.${menu.key})`);
            });
        }
        else {
            this.logger.log("\tNo modal detected");
        }
        this.logger.log("");
        this.logger.log("client >> reactions");
        if (this.reactions.length) {
            this.reactions.forEach((menu) => {
                this.logger.log(`>> ${menu.emoji} (${menu.classRef.name}.${menu.key})`);
            });
        }
        else {
            this.logger.log("\tNo reaction detected");
        }
        this.logger.log("");
        this.logger.log("client >> context menu's");
        const contexts = [
            ...this.applicationCommandUsers,
            ...this.applicationCommandMessages,
        ];
        if (contexts.length) {
            contexts.forEach((menu) => {
                this.logger.log(`>> ${menu.name} (${menu.type}) (${menu.classRef.name}.${menu.key})`);
            });
        }
        else {
            this.logger.log("\tNo context menu detected");
        }
        this.logger.log("");
        this.logger.log("client >> application commands");
        if (this.applicationCommands.length) {
            this.applicationCommands.map((DCommand, index) => {
                if (DCommand.botIds.length && !DCommand.botIds.includes(this.botId)) {
                    return;
                }
                this.logger.log(`${index !== 0 ? "\n" : ""}\t>> ${DCommand.name} (${DCommand.classRef.name}.${DCommand.key})`);
                const printOptions = (options, depth) => {
                    if (!options) {
                        return;
                    }
                    const tab = Array(depth).join("\t\t");
                    options.forEach((option, optionIndex) => {
                        this.logger.log(`${(option.type === discord_js_1.ApplicationCommandOptionType.Subcommand ||
                            option.type ===
                                discord_js_1.ApplicationCommandOptionType.SubcommandGroup) &&
                            optionIndex !== 0
                            ? "\n"
                            : ""}${tab}>> ${option.type === discord_js_1.ApplicationCommandOptionType.Subcommand ||
                            option.type === discord_js_1.ApplicationCommandOptionType.SubcommandGroup
                            ? option.name
                            : option.name}: ${discord_js_1.ApplicationCommandOptionType[option.type]?.toLowerCase()} (${option.classRef.name}.${option.key})`);
                        printOptions(option.options, depth + 1);
                    });
                };
                printOptions(DCommand.options, 2);
            });
        }
        else {
            this.logger.log("\tNo application command detected");
        }
        this.logger.log("");
        this.logger.log("client >> simple commands");
        if (this.simpleCommands.length) {
            this.simpleCommands.map((cmd) => {
                this.logger.log(`\t>> ${cmd.name} (${cmd.classRef.name}.${cmd.key})`);
                if (cmd.aliases.length) {
                    this.logger.log(`\t\t${"aliases"}:`, cmd.aliases.join(", "));
                }
                const printOptions = (options, depth) => {
                    if (!options) {
                        return;
                    }
                    const tab = Array(depth).join("\t\t");
                    options.forEach((option) => {
                        this.logger.log(`${tab}${option.name}: ${index_js_1.SimpleCommandOptionType[option.type] ?? "unknown"} (${option.classRef.name}.${option.key})`);
                    });
                };
                printOptions(cmd.options, 2);
                this.logger.log("");
            });
        }
        else {
            this.logger.log("\tNo simple command detected");
        }
        this.logger.log("\n");
    }
    /**
     * Get commands mapped by guild id (in case of multi bot, commands are filtered for this client only)
     * @returns
     */
    async CommandByGuild() {
        const botResolvedGuilds = await this.botResolvedGuilds;
        // # group guild commands by guildId
        const guildDCommandStore = new Map();
        const allGuildDCommands = this.applicationCommands.filter((DCommand) => DCommand.isBotAllowed(this.botId) &&
            [...botResolvedGuilds, ...DCommand.guilds].length);
        // group single guild commands together
        await Promise.all(allGuildDCommands.map(async (DCommand) => {
            const guilds = await (0, index_js_1.resolveIGuilds)(this, DCommand, [
                ...botResolvedGuilds,
                ...DCommand.guilds,
            ]);
            guilds.forEach((guild) => guildDCommandStore.set(guild, [
                ...(guildDCommandStore.get(guild) ?? []),
                DCommand,
            ]));
        }));
        return guildDCommandStore;
    }
    /**
     * Initialize all the @Slash
     */
    async initApplicationCommands(options) {
        const allGuildPromises = [];
        const guildDCommandStore = await this.CommandByGuild();
        // run task to add/update/delete slashes for guilds
        guildDCommandStore.forEach((DCommands, guildId) => {
            // If bot is not in guild, skip it
            const guild = this.guilds.cache.get(guildId);
            if (!guild) {
                return;
            }
            allGuildPromises.push(this.initGuildApplicationCommands(guildId, DCommands, options?.guild));
        });
        await Promise.all([
            Promise.all(allGuildPromises),
            this.initGlobalApplicationCommands(options?.global),
        ]);
    }
    /**
     * Init application commands for guild
     * @param guildId - Guild identifier
     * @param DCommands - Array of commands
     * @param options - Options
     */
    async initGuildApplicationCommands(guildId, DCommands, options) {
        const botResolvedGuilds = await this.botResolvedGuilds;
        const guild = this.guilds.cache.get(guildId);
        if (!guild) {
            this.logger.error(`${this.user?.username ?? this.botId} >> initGuildApplicationCommands: guild unavailable: ${guildId}`);
            return;
        }
        // fetch already registered application command
        const ApplicationCommands = await guild.commands.fetch({
            withLocalizations: true,
        });
        // filter only unregistered application command
        const commandsToAdd = DCommands.filter((DCommand) => !ApplicationCommands.find((cmd) => cmd.name === DCommand.name && cmd.type === DCommand.type));
        // filter application command to update
        const commandsToUpdate = [];
        const commandsToSkip = [];
        DCommands.map((DCommand) => {
            const findCommand = ApplicationCommands.find((cmd) => cmd.name === DCommand.name && cmd.type === DCommand.type);
            if (!findCommand) {
                return;
            }
            if (!(0, index_js_1.isApplicationCommandEqual)(findCommand, DCommand, true)) {
                commandsToUpdate.push(new index_js_1.ApplicationCommandMixin(findCommand, DCommand));
            }
            else {
                commandsToSkip.push(new index_js_1.ApplicationCommandMixin(findCommand, DCommand));
            }
        });
        // filter commands to delete
        const commandsToDelete = [];
        await Promise.all(ApplicationCommands.map(async (cmd) => {
            const DCommandFind = DCommands.find((DCommand) => DCommand.name === cmd.name && DCommand.type === cmd.type);
            // delete command if it's not found
            if (!DCommandFind) {
                commandsToDelete.push(cmd);
                return;
            }
            const guilds = await (0, index_js_1.resolveIGuilds)(this, DCommandFind, [
                ...botResolvedGuilds,
                ...DCommandFind.guilds,
            ]);
            // delete command if it's not registered for given guild
            if (!cmd.guildId || !guilds.includes(cmd.guildId)) {
                commandsToDelete.push(cmd);
                return;
            }
        }));
        // log the changes to commands if enabled by options or silent mode is turned off
        if (options?.log ?? !this.silent) {
            let str = `${this.user?.username} >> commands >> guild: #${guild}`;
            str += `\n\t>> adding   ${commandsToAdd.length} [${commandsToAdd
                .map((DCommand) => DCommand.name)
                .join(", ")}] ${options?.disable?.add ? "[task disabled]" : ""}`;
            str += `\n\t>> updating ${commandsToUpdate.length} [${commandsToUpdate
                .map((cmd) => cmd.command.name)
                .join(", ")}] ${options?.disable?.update ? "[task disabled]" : ""}`;
            str += `\n\t>> deleting ${commandsToDelete.length} [${commandsToDelete
                .map((cmd) => cmd.name)
                .join(", ")}] ${options?.disable?.delete ? "[task disabled]" : ""}`;
            str += `\n\t>> skipping ${commandsToSkip.length} [${commandsToSkip
                .map((cmd) => cmd.name)
                .join(", ")}]`;
            str += "\n";
            this.logger.info(str);
        }
        // If there are no changes to share with Discord, cancel the task
        if (commandsToAdd.length +
            commandsToUpdate.length +
            commandsToDelete.length ===
            0) {
            return;
        }
        // perform bulk update with discord using set operation
        const bulkUpdate = [];
        const operationToSkip = commandsToSkip.map((cmd) => bulkUpdate.push(cmd.instance.toJSON()));
        const operationToAdd = options?.disable?.add
            ? []
            : commandsToAdd.map((DCommand) => bulkUpdate.push(DCommand.toJSON()));
        const operationToUpdate = options?.disable?.update
            ? commandsToUpdate.map(async (cmd) => bulkUpdate.push((await cmd.command.toJSON())))
            : commandsToUpdate.map((cmd) => bulkUpdate.push(cmd.instance.toJSON()));
        const operationToDelete = options?.disable?.delete
            ? commandsToDelete.map(async (cmd) => bulkUpdate.push((await cmd.toJSON())))
            : [];
        await Promise.all([
            // skipped
            ...operationToSkip,
            // add
            ...operationToAdd,
            // update
            ...operationToUpdate,
            // delete
            ...operationToDelete,
        ]);
        await guild.commands.set(bulkUpdate);
    }
    /**
     * Init global application commands
     *
     * @param options - Options
     */
    async initGlobalApplicationCommands(options) {
        const botResolvedGuilds = await this.botResolvedGuilds;
        if (!this.application) {
            throw Error("The client is not yet ready, connect to discord before fetching commands");
        }
        // # initialize add/update/delete task for global commands
        const ApplicationCommands = (await this.application.commands.fetch())?.filter((cmd) => !cmd.guild);
        const DCommands = this.applicationCommands.filter((DCommand) => ![...botResolvedGuilds, ...DCommand.guilds].length &&
            (!DCommand.botIds.length || DCommand.botIds.includes(this.botId)));
        const commandsToAdd = DCommands.filter((DCommand) => !ApplicationCommands.find((cmd) => cmd.name === DCommand.name && cmd.type === DCommand.type));
        const commandsToUpdate = [];
        const commandsToSkip = [];
        DCommands.map((DCommand) => {
            const findCommand = ApplicationCommands.find((cmd) => cmd.name === DCommand.name && cmd.type == DCommand.type);
            if (!findCommand) {
                return;
            }
            if (!(0, index_js_1.isApplicationCommandEqual)(findCommand, DCommand)) {
                commandsToUpdate.push(new index_js_1.ApplicationCommandMixin(findCommand, DCommand));
            }
            else {
                commandsToSkip.push(new index_js_1.ApplicationCommandMixin(findCommand, DCommand));
            }
        });
        const commandsToDelete = ApplicationCommands.filter((cmd) => DCommands.every((DCommand) => DCommand.name !== cmd.name || DCommand.type !== cmd.type));
        // log the changes to commands if enabled by options or silent mode is turned off
        if (options?.log ?? !this.silent) {
            let str = `${this.user?.username ?? this.botId} >> commands >> global`;
            str += `\n\t>> adding   ${commandsToAdd.length} [${commandsToAdd
                .map((DCommand) => DCommand.name)
                .join(", ")}] ${options?.disable?.add ? "[task disabled]" : ""}`;
            str += `\n\t>> updating ${commandsToUpdate.length} [${commandsToUpdate
                .map((cmd) => cmd.command.name)
                .join(", ")}] ${options?.disable?.update ? "[task disabled]" : ""}`;
            str += `\n\t>> deleting ${commandsToDelete.size} [${commandsToDelete
                .map((cmd) => cmd.name)
                .join(", ")}] ${options?.disable?.delete ? "[task disabled]" : ""}`;
            str += `\n\t>> skipping ${commandsToSkip.length} [${commandsToSkip
                .map((cmd) => cmd.name)
                .join(", ")}]`;
            str += "\n";
            this.logger.info(str);
        }
        // If there are no changes to share with Discord, cancel the task
        if (commandsToAdd.length + commandsToUpdate.length + commandsToDelete.size ===
            0) {
            return;
        }
        // perform bulk update with discord using set operation
        const bulkUpdate = [];
        const operationToSkip = commandsToSkip.map((cmd) => bulkUpdate.push(cmd.instance.toJSON()));
        const operationToAdd = options?.disable?.add
            ? []
            : commandsToAdd.map((DCommand) => bulkUpdate.push(DCommand.toJSON()));
        const operationToUpdate = options?.disable?.update
            ? commandsToUpdate.map((cmd) => bulkUpdate.push(cmd.command.toJSON()))
            : commandsToUpdate.map((cmd) => bulkUpdate.push(cmd.instance.toJSON()));
        const operationToDelete = options?.disable?.delete
            ? commandsToDelete.map((cmd) => bulkUpdate.push(cmd.toJSON()))
            : [];
        await Promise.all([
            // skipped
            ...operationToSkip,
            // add
            ...operationToAdd,
            // update
            ...operationToUpdate,
            // delete
            ...operationToDelete,
        ]);
        await this.application?.commands.set(bulkUpdate);
    }
    /**
     * Clear the application commands globally or for some guilds
     *
     * @param guilds - The guild Ids (empty -> globally)
     */
    async clearApplicationCommands(...guilds) {
        if (guilds.length) {
            await Promise.all(
            // Select and delete the commands of each guild
            guilds.map((guild) => {
                this.guilds.cache.get(guild)?.commands.set([]);
            }));
        }
        else {
            await this.application?.commands.set([]);
        }
    }
    /**
     * Get the group tree of an slash interaction
     * /hello => ["hello"]
     * /test hello => ["test", "hello"]
     * /test hello me => ["test", "hello", "me"]
     *
     * @param interaction - The targeted slash interaction
     *
     * @returns
     */
    getApplicationCommandGroupTree(interaction) {
        const tree = [];
        const getOptionsTree = (option) => {
            if (!option) {
                return;
            }
            if (!option.type ||
                option.type === discord_js_1.ApplicationCommandOptionType.SubcommandGroup ||
                option.type === discord_js_1.ApplicationCommandOptionType.Subcommand) {
                if (option.name) {
                    tree.push(option.name);
                }
                return getOptionsTree(Array.from(option.options?.values() ?? [])?.[0]);
            }
        };
        getOptionsTree({
            name: interaction.commandName,
            options: Array.from(interaction.options.data.values()),
            type: undefined,
        });
        return tree;
    }
    /**
     * Return the corresponding @Slash from a tree
     *
     * @param tree - Array of string
     *
     * @returns
     */
    getApplicationCommandFromTree(tree) {
        // Find the corresponding @Slash
        return this.applicationCommandSlashesFlat.find((slash) => {
            switch (tree.length) {
                case 1:
                    // Simple command /hello
                    return (slash.group === undefined &&
                        slash.subgroup === undefined &&
                        slash.name === tree[0] &&
                        slash.type === discord_js_1.ApplicationCommandType.ChatInput);
                case 2:
                    // Simple grouped command
                    // /permission user perm
                    return (slash.group === tree[0] &&
                        slash.subgroup === undefined &&
                        slash.name === tree[1] &&
                        slash.type === discord_js_1.ApplicationCommandType.ChatInput);
                case 3:
                    // Grouped and subgrouped command
                    // /permission user perm
                    return (slash.group === tree[0] &&
                        slash.subgroup === tree[1] &&
                        slash.name === tree[2] &&
                        slash.type === discord_js_1.ApplicationCommandType.ChatInput);
            }
        });
    }
    /**
     * Execute all types of interaction
     *
     * @param interaction - Interaction
     * @param log - Enable log
     *
     * @returns
     */
    executeInteraction(interaction, log) {
        if (!interaction) {
            if (log ?? !this.silent) {
                this.logger.error(`${this.user?.username ?? this.botId} >> interaction is undefined`);
            }
            return;
        }
        // if interaction is a button
        if (interaction.isButton()) {
            return this.executeComponent(this.buttonComponents, interaction, log);
        }
        // if interaction is a modal
        if (interaction.type === discord_js_1.InteractionType.ModalSubmit) {
            return this.executeComponent(this.modalComponents, interaction, log);
        }
        // if interaction is a select menu
        if (interaction.isSelectMenu()) {
            return this.executeComponent(this.selectMenuComponents, interaction, log);
        }
        // if interaction is context menu
        if (interaction.isContextMenuCommand()) {
            return this.executeContextMenu(interaction, log);
        }
        // If the interaction isn't a slash command, return
        if (interaction.type === discord_js_1.InteractionType.ApplicationCommand ||
            interaction.type === discord_js_1.InteractionType.ApplicationCommandAutocomplete) {
            return this.executeCommandInteraction(interaction, log);
        }
    }
    /**
     * Execute command interaction
     *
     * @param interaction - Interaction instance
     * @param log - Enable log
     *
     * @returns
     */
    executeCommandInteraction(interaction, log) {
        // Get the interaction group tree
        const tree = this.getApplicationCommandGroupTree(interaction);
        const applicationCommand = this.getApplicationCommandFromTree(tree);
        if (!applicationCommand?.isBotAllowed(this.botId)) {
            if (log ?? !this.silent) {
                this.logger.error(`${this.user?.username ?? this.botId} >> interaction not found, commandName: ${interaction.commandName}`);
            }
            return;
        }
        if (interaction.type === discord_js_1.InteractionType.ApplicationCommandAutocomplete) {
            const focusOption = interaction.options.getFocused(true);
            const option = applicationCommand.options.find((op) => op.name === focusOption.name);
            if (option && typeof option.autocomplete === "function") {
                option.autocomplete.call(di_1.DIService.instance.getService(option.from), interaction, applicationCommand);
                return;
            }
        }
        // Parse the options values and inject it into the @Slash method
        return applicationCommand.execute(this.guards, interaction, this);
    }
    /**
     * Execute component interaction
     *
     * @param interaction - Interaction instance
     * @param log - Enable log
     *
     * @returns
     */
    async executeComponent(components, interaction, log) {
        const executes = components.filter((comp) => comp.isId(interaction.customId));
        const results = await Promise.all(executes.map(async (component) => {
            if (!component?.isBotAllowed(this.botId) ||
                !(await component.isGuildAllowed(this, interaction.guildId))) {
                return undefined;
            }
            else {
                return component.execute(this.guards, interaction, this);
            }
        }));
        if ((log ?? !this.silent) && !results.some((res) => res)) {
            this.logger.error(`${this.user?.username ?? this.botId} >> ${interaction.isButton()
                ? "button"
                : interaction.isSelectMenu()
                    ? "select menu"
                    : "modal"} component handler not found, interactionId: ${interaction.id} | customId: ${interaction.customId}`);
        }
        return results;
    }
    /**
     * Execute context menu interaction
     *
     * @param interaction - Interaction instance
     * @param log - Enable log
     *
     * @returns
     */
    async executeContextMenu(interaction, log) {
        const applicationCommand = interaction.isUserContextMenuCommand()
            ? this.applicationCommandUsers.find((cmd) => cmd.name === interaction.commandName)
            : this.applicationCommandMessages.find((cmd) => cmd.name === interaction.commandName);
        if (!applicationCommand?.isBotAllowed(this.botId) ||
            !(await applicationCommand.isGuildAllowed(this, interaction.guildId))) {
            if (log ?? !this.silent) {
                this.logger.error(`${this.user?.username ?? this.botId} >> context interaction not found, name: ${interaction.commandName}`);
            }
            return;
        }
        if (applicationCommand.botIds.length &&
            !applicationCommand.botIds.includes(this.botId)) {
            return;
        }
        return applicationCommand.execute(this.guards, interaction, this);
    }
    /**
     * Fetch prefix for message
     *
     * @param message - Message instance
     *
     * @returns
     */
    async getMessagePrefix(message) {
        if (typeof this.prefix !== "function") {
            return lodash_1.default.isArray(this.prefix) ? [...this.prefix] : [this.prefix];
        }
        return [...(await this.prefix(message))];
    }
    /**
     * Parse command message
     *
     * @param prefix - Command prefix
     * @param message - Original message
     * @param caseSensitive - Execute case-sensitively
     *
     * @returns
     */
    async parseCommand(prefix, message, caseSensitive = false) {
        const mappedPrefix = Array.from(this.simpleCommandsByPrefix.keys());
        const prefixRegex = RegExp(`^(${[...prefix, ...mappedPrefix]
            .map((pfx) => lodash_1.default.escapeRegExp(pfx))
            .join("|")})`);
        const isCommand = prefixRegex.test(message.content);
        if (!isCommand) {
            return index_js_1.SimpleCommandParseType.notCommand;
        }
        const matchedPrefix = prefixRegex.exec(message.content)?.at(1) ?? "unknown";
        const isPrefixBaseCommand = mappedPrefix.includes(matchedPrefix);
        const contentWithoutPrefix = `${message.content
            .replace(prefixRegex, "")
            .trim()} `;
        const commandRaw = (isPrefixBaseCommand
            ? this.simpleCommandsByPrefix.get(matchedPrefix) ?? []
            : this.simpleCommandsByName).find((cmd) => {
            if (caseSensitive) {
                return contentWithoutPrefix.startsWith(`${cmd.name} `);
            }
            return contentWithoutPrefix
                .toLowerCase()
                .startsWith(`${cmd.name.toLowerCase()} `);
        });
        if (!commandRaw) {
            return index_js_1.SimpleCommandParseType.notFound;
        }
        const commandArgs = contentWithoutPrefix
            .replace(new RegExp(commandRaw.name, "i"), "")
            .trim();
        const command = new index_js_1.SimpleCommandMessage(matchedPrefix, commandArgs, message, commandRaw.command, this.simpleCommandConfig?.argSplitter);
        command.options = await command.resolveOptions();
        return command;
    }
    /**
     * Execute the corresponding @SimpleCommand based on an message instance
     *
     * @param message - Message instance
     * @param options - Options
     *
     * @returns
     */
    async executeCommand(message, options) {
        if (!message) {
            if (options?.log ?? !this.silent) {
                this.logger.error(`${this.user?.username ?? this.botId} >> executeCommand >> message is undefined`);
            }
            return;
        }
        const prefix = await this.getMessagePrefix(message);
        if (!prefix) {
            if (options?.log ?? !this.silent) {
                this.logger.error(`${this.user?.username ?? this.botId} >> executeCommand >> command prefix not found`);
            }
            return;
        }
        const command = await this.parseCommand(prefix, message, options?.caseSensitive ?? false);
        if (command === index_js_1.SimpleCommandParseType.notCommand) {
            return;
        }
        if (command === index_js_1.SimpleCommandParseType.notFound) {
            const handleNotFound = this.simpleCommandConfig?.responses?.notFound;
            if (handleNotFound) {
                if (typeof handleNotFound === "string") {
                    message.reply(handleNotFound);
                }
                else {
                    handleNotFound(message);
                }
            }
            return;
        }
        // validate bot id
        if (!command.info.isBotAllowed(this.botId)) {
            return;
        }
        // validate guild id
        if (!(await command.info.isGuildAllowed(this, command, message.guildId))) {
            return;
        }
        // check dm allowed or not
        if (!command.info.directMessage && !message.guild) {
            return;
        }
        return command.info.execute(this.guards, command, this);
    }
    /**
     * Parse reaction
     *
     * @param message - Original reaction
     *
     * @returns
     */
    parseReaction(message) {
        const reaction = this.reactions.find((react) => {
            const validNames = [react.emoji, ...react.aliases];
            const { emoji } = message;
            return ((emoji.id ? validNames.includes(emoji.id) : false) ||
                (emoji.name ? validNames.includes(emoji.name) : false));
        });
        return reaction;
    }
    /**
     * Execute the corresponding @Reaction based on an message reaction instance
     *
     * @param reaction - MessageReaction instance
     * @param options - Options
     *
     * @returns
     */
    async executeReaction(reaction, user, options) {
        if (!reaction) {
            if (options?.log ?? !this.silent) {
                this.logger.error(`${this.user?.username ?? this.botId} >> executeReaction >> reaction is undefined`);
            }
            return;
        }
        const action = this.parseReaction(reaction);
        if (!action) {
            return;
        }
        // validate bot id
        if (!action.isBotAllowed(this.botId)) {
            return;
        }
        // validate guild id
        if (!(await action.isGuildAllowed(this, reaction.message.guildId))) {
            return;
        }
        // check dm allowed or not
        if (!action.directMessage && !reaction.message.guild) {
            return;
        }
        // fetch reaction or user if partial is not enabled
        if (!action.partial && reaction.partial) {
            reaction = await reaction.fetch();
        }
        if (!action.partial && user.partial) {
            user = await user.fetch();
        }
        // remove reaction if remove is enabled
        if (action.remove) {
            await reaction.users.remove(user.id);
        }
        return action.execute(this.guards, reaction, user, this);
    }
    /**
     * Trigger an event manually (used for testing)
     *
     * @param options - Event data
     * @param params - Params to inject
     *
     * @returns
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    trigger(options, params) {
        return this.instance.trigger(options)(params);
    }
    /**
     * Manually build client
     *
     * @param log - Enable log
     */
    async build(log) {
        if (this._isBuilt) {
            return;
        }
        this._isBuilt = true;
        await this.instance.build();
        if (log ?? !this.silent) {
            this.printDebug();
        }
        for (const on of this.instance.usedEvents) {
            if (on.rest) {
                if (on.once) {
                    this.rest.once(on.event, this.instance.trigger({
                        client: this,
                        event: on.event,
                        guards: this.guards,
                        once: true,
                        rest: true,
                    }));
                }
                else {
                    this.rest.on(on.event, this.instance.trigger({
                        client: this,
                        event: on.event,
                        guards: this.guards,
                        once: false,
                        rest: true,
                    }));
                }
            }
            else {
                if (on.once) {
                    this.once(on.event, this.instance.trigger({
                        client: this,
                        event: on.event,
                        guards: this.guards,
                        once: true,
                        rest: false,
                    }));
                }
                else {
                    this.on(on.event, this.instance.trigger({
                        client: this,
                        event: on.event,
                        guards: this.guards,
                        once: false,
                        rest: false,
                    }));
                }
            }
        }
    }
}
exports.Client = Client;
//# sourceMappingURL=Client.js.map